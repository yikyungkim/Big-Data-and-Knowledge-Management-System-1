<div class="notebook">

<div class="nb-cell markdown" name="md1">
# Assignment 2: Bill Of Materials (BOM) Data on Prolog

### Due: Fri May 15th, 23:59

Assignment submitted after its deadline will be penalized one percent from the total score for every five minutes late. SNU eTL submissions are always timestamped, so submitting electronically is a reliable way to guarantee you get the earliest possible time of submission. We will not accept any email submission.

Ex) Suppose that a student A submitted the homework 7 minutes late. Then 2% will be deducted from his or her assignment score. We will calculate Deducted Points according to the following equation: *Total Possible Points * (1 - 0.01 * ceil(delay / 5min))*

### Submission

After you have completed the assignment, you need to submit the following deliverable:

 - hw2.zip - Download the swish notebook, compress (zip) the downloaded file, and submit it to the SNU eTL. You can download the swish notebook file using *File -&gt; Download Tab* above.
 
### Score (Total 10 points)
 - Question A (*2 pts*)
 - Question B (*2 pts*)
 - Question C (*3 pts*)
 - Question D (*3 pts*)
 - Bonus Question (*extra 2 pts*)
  - You can earn bonus points, but your score will be capped at 10 (If you get 9 pts in A~D and get extra 2 pts from bonus question, then you will get a total of 10 pts not 11).
  
## Bill Of Materials Data
A bill of materials (BOM) is a list of the raw materials, sub-assemblies, intermediate assemblies, sub-components, parts, and the quantities of each needed to manufacture an end product.

[Reference: Wikipedia](https://en.wikipedia.org/wiki/Bill_of_materials)

The following *Products* table and *BOM* table represent the product-company and sub-component relationship respectively.
</div>

<div class="nb-cell html" name="htm2">
<img src="https://raw.githubusercontent.com/jhleepidl/2022_Spring_BKMS/main/bom_products_table.png" width="100%">
</div>

<div class="nb-cell markdown" name="md3">
For example, to make *product 104*, one *product 251* and two *products 28* are required, and to make *product 28*, *product 130* and *product 195* are required.

A diagram of the hierarchical bill of materials is as follows:
</div>

<div class="nb-cell html" name="htm3">
<img src="https://raw.githubusercontent.com/jhleepidl/2022_Spring_BKMS/main/bom_example_modified.png" width="100%">
</div>

<div class="nb-cell markdown" name="md21">
Numbers in the rectangle represents *Product ID*, and arrows are to show the direction of the relationship between *two Product IDs* in the BOM Table (Pid_parent -&gt; Pid_sub).
</div>

<div class="nb-cell markdown" name="md2">
## Load BOM Data to Prolog

First, load two files 'Products.csv', 'BOM.csv' to Prolog.

We will refer to swish data_sources examples to import csv files.
 - ref: [Accessing external *data*](example/data_source.swinb) (CSV, SPARQL, etc.)

The Prolog program cell below will import 'Products.csv' and 'BOM.csv'
</div>

<div class="nb-cell program" data-background="true" name="p1">
:- data_source(csv1,
               csv('https://raw.githubusercontent.com/jhleepidl/2022_Spring_BKMS/main/Products.csv',
                   [])).

products(Pid, Product, Company, Unitprice) :-
    csv1{'PID':Pid, 'Product':Product, 'Company':Company, 'Unit_price':Unitprice}.
:- data_source(csv2,
               csv('https://raw.githubusercontent.com/jhleepidl/2022_Spring_BKMS/main/BOM.csv',
                   [])).

bom(Pidsub, Pidparent, Quant) :-
    csv2{'Pid_sub':Pidsub, 'Pid_parent':Pidparent, 'Quantity':Quant}.
</div>

<div class="nb-cell html" name="htm8">

</div>

<div class="nb-cell markdown" name="md4">
You can check the rows using queries below:
</div>

<div class="nb-cell query" name="q1">
products(Pid, Product, Company, Unitprice).
</div>

<div class="nb-cell markdown" name="md5">
The result of query below returns 'Pidsub = Quantity'.

But, it is not an error because Pidsub = Quantity = 1.
</div>

<div class="nb-cell query" name="q2">
bom(Pidsub, Pidparent, Quantity).
</div>

<div class="nb-cell markdown" name="md14">
You can also count the rows of each data.
</div>

<div class="nb-cell query" name="q5">
aggregate_all(count, (products(Pid, Product, Company, Unitprice)), Count).
</div>

<div class="nb-cell html" name="htm1">

</div>

<div class="nb-cell query" name="q6">
aggregate_all(count, (bom(Pidsub, Pidparent, Quantity)), Count).
</div>

<div class="nb-cell markdown" name="md6">
## Question A (2 pts)

Write a query with your own rule using *products()* or *bom()* predicate.

Ex) Find all products name and manufacturer whose unit price is larger than X. 

Hint: See *Practice Note 2: Prolog* p.26-30
</div>

<div class="nb-cell program" name="p4">
%TODO: write your own rule
quantity_greater_than(X, Pidparent, Quantity) :-
    bom(_Pidsub, Pidparent, Quantity),
    Quantity &gt; X.
</div>

<div class="nb-cell query" name="q3">
%TODO: write your own query using the rule above
quantity_greater_than(2, Pidparent, Quantity)
</div>

<div class="nb-cell markdown" name="md7">
## Question B (2 pts)

Complete the rule *supplies(CompanyFrom, CompanyTo, ProductA, ProductB)* in the program cell below.

*supplies(CompanyFrom, CompanyTo, ProductA, ProductB)* rule is true when below conditions are all true.

 - *CompanyFrom* is the manufacturer of *ProductA*
 - *CompanyTo* is the manufacturer of *ProductB*
 - *ProductA* is the sub-component of *ProductB*
 
Note that *ProductA* and *ProductB* are variables for product names
</div>

<div class="nb-cell program" data-background="true" name="p2">
supplies(CompanyFrom, CompanyTo, ProductA, ProductB) :-
    %TODO: Define supplies rule
    products(PidA, ProductA, CompanyFrom, _UnitPriceA),
    products(PidB, ProductB, CompanyTo, _UnitPriceB),
	bom(PidA, PidB, _Quantity).

</div>

<div class="nb-cell markdown" name="md8">
You can test the output with the query below
</div>

<div class="nb-cell query" name="q4">
supplies(Company,'Ampine',Sub,Parent).
</div>

<div class="nb-cell markdown" name="md9">
The result should be as follows:
</div>

<div class="nb-cell html" name="htm4">
<img src="https://raw.githubusercontent.com/jhleepidl/2022_Spring_BKMS/main/QB_result.png" width="40%">
</div>

<div class="nb-cell markdown" name="md10">
## Question C (3 pts)

The *checkconnected()* checks whether two companies are connected via sub-component relationships.

Complete *trace(ProductA, ProductB, Visited, Path)* rule below to recursively find path between products

You may refer to Prolog list implementation to solve this question.
 - [Prolog list tutorial](https://www.cpp.edu/~jrfisher/www/prolog_tutorial/2_7.html)

#### [Hint](https://www.cpp.edu/~jrfisher/www/prolog_tutorial/2_15.html)
</div>

<div class="nb-cell program" data-background="true" name="p3">
checkconnected(CompanyFrom, CompanyTo, Path):-
    products(_PidA, ProductA, CompanyFrom, _UnitPriceA),
    products(_PidB, ProductB, CompanyTo, _UnitPriceB),
    trace(ProductA, ProductB, [ProductA], Q),
    reverse(Q, Path).

% Base case of recursion
trace(ProductA, ProductB, P, [ProductB|P]):-
    supplies(_CompanyFrom, _CompanyTo, ProductA, ProductB).

trace(ProductA, ProductB, Visited, Path) :-
    %TODO: Define trace rule to recursively find path
    supplies(_CompanyFrom2, _CompanyTo2, ProductA, ProductC),
    ProductC \== ProductB,
    \+member(ProductC, Visited),
    trace(ProductC, ProductB, [ProductC|Visited], Path).
</div>

<div class="nb-cell markdown" name="md16">
You can test the output with the query below
</div>

<div class="nb-cell query" name="q9">
checkconnected(Company,'Ampine',Chain).
</div>

<div class="nb-cell markdown" name="md17">
The result should be as follows:
</div>

<div class="nb-cell html" name="htm6">
<img src="https://raw.githubusercontent.com/jhleepidl/2022_Spring_BKMS/main/QC_result.png" width="40%">
</div>

<div class="nb-cell html" name="htm5">

</div>

<div class="nb-cell markdown" name="md11">
## Question D (3 pts)

Analyze the pros and cons of using Prolog as a database management system.

You can compare Prolog with PostgreSQL.
</div>

<div class="nb-cell markdown" name="md12">
-----------------------------------------------------
TODO: Write the pros and cons of using Prolog as a database management system.

*Double-click* here to modify this markdown cell

Pros of using Prolog as a database management system:
	- Prolog stores data and generate output in a logical way like postgreSQL. 
    - It is useful to perform symbolic and logic-based computation.
    - It features depth-first-search for searching algorithm, so if you are solving for DFS question, Prolog can be a good tool for it.
	- Prolog is easy to buil a database without a lot of programming effort.
    - Since it has built in list handling, it is easy to build an algorithm for lists
    
Cons of using Prolog as a database management system:
	- Prolog only provides logical condition, and it doesn't work for negative statements.
    - It is in first order logic, and it does not support second order logic directly.
    - Prolog does not support input/output feature.
    
-----------------------------------------------------
</div>

<div class="nb-cell markdown" name="md13">
## Bonus Question (extra 2 pts)

Write a query that visualize product assembly path.

We will use graphviz to render graphs.
 - ref: [Using Graphviz to display graphs](example/render_graphviz.swinb)
</div>

<div class="nb-cell program" data-background="true" name="p5">
:- use_rendering(graphviz).
</div>

<div class="nb-cell markdown" name="md18">
You can visualize graphs using queries like below.

Feel free check out more visualization examples in the reference.
</div>

<div class="nb-cell query" name="q10">
X = dot(digraph(['X' -&gt; 'Y' -&gt; 'Z'])).
</div>

<div class="nb-cell markdown" name="md15">
Use the program provided below to create a query that visualizes the assembly path.

You are allow to modify the cell below.
</div>

<div class="nb-cell program" name="p6">
product_supply(ProductA, ProductB) :-
    products(PidA,ProductA,_CompanyFrom,_UnitpriceA),
    products(PidB,ProductB,_CompanyTo,_UnitpriceB),
    bom(PidA, PidB, _Quantity).

checkpath(ProductA, ProductB, Path):-
    tracearrow(ProductA, ProductB, ProductA, Path),
    \+product_supply(_Anyproduct,ProductA).

tracearrow(ProductA, ProductB, P, ProductB -&gt; P):-
    product_supply(ProductA, ProductB).

tracearrow(ProductA, ProductB, Visited, Path) :-
    product_supply(ProductA, ProductC),
    ProductC \== ProductB,
    \+member(ProductC, Visited),
    tracearrow(ProductC, ProductB, ProductC -&gt; Visited, Path).
</div>

<div class="nb-cell markdown" name="md19">
Write a query to visualize assembly path from final product 'T21P'
</div>

<div class="nb-cell query" name="q8">
%TODO: write a query to visualize assembly path from final product 'T21P'
checkpath(Product,'T21P',Path),
X = dot(digraph([Path])).
</div>

<div class="nb-cell markdown" name="md20">
The result should be as follows:
</div>

<div class="nb-cell html" name="htm7">
<img src="https://raw.githubusercontent.com/jhleepidl/2022_Spring_BKMS/main/QE_result.png" width="30%">
</div>

</div>
